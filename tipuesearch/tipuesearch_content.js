var tipuesearch = {"pages":[{"title":" daglib ","text":"daglib Overview DAGLIB is a modern Fortran module for creating and manipulating directed acyclic graphs (DAGs). It includes a toposort feature, and also the ability to generate files in the GraphViz \"dot\" notation. Building A Fortran Package Manager manifest file is included, so that the library and tests cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release By default, the library is built with single precision ( int32 ) integer values. Explicitly specifying the integer kind can be done using the following processor flag: Preprocessor flag Kind Number of bytes INT8 integer(kind=int8) 1 INT16 integer(kind=int16) 2 INT32 integer(kind=int32) 4 INT64 integer(kind=int64) 8 For example, to build a long integer version of the library: fpm build --profile release --flag \"-DINT64\" Example A simple example is shown below: program dag_example use dag_module implicit none type ( dag ) :: d integer , dimension (:), allocatable :: order integer :: istat integer :: i integer , parameter :: n_nodes = 6 character ( len =* ), parameter :: filetype = 'pdf' ! create a dag: call d % set_vertices ( n_nodes ) call d % set_edges ( 2 ,[ 1 ]) ! 2 depends on 1 call d % set_edges ( 3 ,[ 5 , 1 ]) ! 3 depends on 5 and 1 call d % set_edges ( 4 ,[ 5 ]) ! 4 depends on 5 call d % set_edges ( 5 ,[ 2 ]) ! 5 depends on 2 call d % set_edges ( 6 ,[ 2 , 4 ]) ! 6 depends on 2 and 4 ! toposort: call d % toposort ( order , istat ) ! define some styles for the GraphViz output: do i = 1 , n_nodes if ( i == 3 . or . i == 6 ) then call d % set_vertex_info ( i , attributes = 'shape=square,fillcolor=\"SlateGray1\",style=filled' ) else call d % set_vertex_info ( i , attributes = 'shape=circle,fillcolor=\"cornsilk\",style=filled' ) end if end do ! generate the GraphViz output: call d % save_digraph ( 'test.dot' , 'RL' , 300 ) call d % destroy () call execute_command_line ( 'dot -Tpdf -o test.pdf test.dot' ) end program dag_example This program produces the toposort order: order = [1, 2, 5, 3, 4, 6] and the image file: Documentation The API documentation for the current master branch can be found here .  This is generated by processing the source files with FORD . License This library is released under a BSD-3 license . See also dag (a fork of this project) Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"edge – daglib ","text":"type, private :: edge the \"to\" vertex that defines an edge. This is part of\nthe array of vertices contained without the \"from\" vertex type.\nan edge can also have optional attrubutes for graphviz. Inherited by type~~edge~~InheritedByGraph type~edge edge type~vertex vertex type~vertex->type~edge edges type~dag dag type~dag->type~vertex vertices Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), public :: ivertex = 0 vertex number (the index in the dag vertices array) character(len=:), public, allocatable :: label used for diagraph character(len=:), public, allocatable :: attributes used for diagraph class(*), public, allocatable :: metadata user-defined metadata Constructor private        interface edge constructor for an edge type. private impure elemental function edge_constructor (ivertex, label, attributes, metadata) result(e) Constructor for edge type. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), optional :: ivertex vertex number defining the destination of this edge character(len=*), intent(in), optional :: label vertex name for grahviz character(len=*), intent(in), optional :: attributes other attributes for graphviz class(*), intent(in), optional :: metadata optional user-defined metadata Return Value type( edge ) Source Code type :: edge !! the \"to\" vertex that defines an edge. This is part of !! the array of vertices contained without the \"from\" [[vertex]] type. !! an edge can also have optional attrubutes for graphviz. integer ( ip ) :: ivertex = 0 !! vertex number (the index in the [[dag]] `vertices` array) character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph class ( * ), allocatable :: metadata !! user-defined metadata end type edge","tags":"","loc":"type/edge.html"},{"title":"vertex – daglib ","text":"type, private :: vertex a vertex (or node) of a directed acyclic graph (DAG) Inherits type~~vertex~~InheritsGraph type~vertex vertex type~edge edge type~vertex->type~edge edges Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~vertex~~InheritedByGraph type~vertex vertex type~dag dag type~dag->type~vertex vertices Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( edge ), private, dimension(:), allocatable :: edges these are the vertices that this vertex\ndepends on. (edges of the graph). integer(kind=ip), private :: ivertex = 0 vertex number (the index in the dag vertices array) logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph class(*), private, allocatable :: metadata user-defined metadata Type-Bound Procedures generic, private :: set_edges => set_edge_vector_vector , add_edge private  subroutine set_edge_vector_vector (me, edges, label, attributes, metadata) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), optional, dimension(:) :: label character(len=*), intent(in), optional, dimension(:) :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata private  subroutine add_edge (me, e, label, attributes, metadata) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e character(len=*), intent(in), optional :: label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata procedure, private :: add_edge private  subroutine add_edge (me, e, label, attributes, metadata) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e character(len=*), intent(in), optional :: label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata procedure, private :: set_edge_vector_vector private  subroutine set_edge_vector_vector (me, edges, label, attributes, metadata) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), optional, dimension(:) :: label character(len=*), intent(in), optional, dimension(:) :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata procedure, private :: remove_edge private  subroutine remove_edge (me, e) remove an edge index from this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e Source Code type :: vertex !! a vertex (or node) of a directed acyclic graph (DAG) private type ( edge ), dimension (:), allocatable :: edges !! these are the vertices that this vertex !! depends on. (edges of the graph). integer ( ip ) :: ivertex = 0 !! vertex number (the index in the [[dag]] `vertices` array) logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph class ( * ), allocatable :: metadata !! user-defined metadata contains private generic :: set_edges => set_edge_vector_vector , add_edge procedure :: set_edge_vector_vector , add_edge procedure :: remove_edge end type vertex","tags":"","loc":"type/vertex.html"},{"title":"dag – daglib ","text":"type, public :: dag a directed acyclic graph (DAG).\na collection of vertices (nodes) that are connected to other vertices. Inherits type~~dag~~InheritsGraph type~dag dag type~vertex vertex type~dag->type~vertex vertices type~edge edge type~vertex->type~edge edges Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer(kind=ip), private :: n = 0 number of vertices (size of vertices array) type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. The index in\nthis array if the vertex number. Type-Bound Procedures procedure, public :: vertex => dag_get_vertex not very useful for now, since\nall vertex attributes are private private  function dag_get_vertex (me, i) result(v) Get the i th vertex. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: i vertex number Return Value type( vertex ) procedure, public :: number_of_vertices => dag_get_number_of_vertices private pure function dag_get_number_of_vertices (me) result(nvertices) Returns the number of vertices (nodes) in the dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me Return Value integer(kind=ip) number of vertices procedure, public :: get_edge_metadata => dag_get_edge_metadata private  function dag_get_edge_metadata (me, ivertex, iedge) result(m) Returns the metadata for an edge in the dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge edge vertex Return Value class(*), allocatable procedure, public :: get_vertex_metadata => dag_get_vertex_metadata private  function dag_get_vertex_metadata (me, ivertex) result(m) Returns the metadata for a vertex (node) in the dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number Return Value class(*), allocatable procedure, public :: get_edges => dag_get_edges private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all of the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex Return Value integer(kind=ip), dimension(:), allocatable procedure, public :: get_dependencies => dag_get_dependencies private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex Return Value integer(kind=ip), dimension(:), allocatable the set of all vertices\nthan depend on ivertex procedure, public :: set_vertices => dag_set_vertices private  subroutine dag_set_vertices (me, nvertices, labels, attributes, metadata) set the number of vertices (nodes) in the dag. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: nvertices number of vertices character(len=*), intent(in), optional, dimension(nvertices) :: labels vertex name strings character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata procedure, public :: set_vertex_info => dag_set_vertex_info private  subroutine dag_set_vertex_info (me, ivertex, label, attributes, metadata) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata procedure, public :: add_edge => dag_add_edge private  subroutine dag_add_edge (me, ivertex, iedge, label, attributes, metadata) Add an edge to a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge the vertex to connect to ivertex character(len=*), intent(in), optional :: label edge label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata generic, public :: set_edges => dag_set_edges_no_atts , dag_set_edges_vector_atts private  subroutine dag_set_edges_no_atts (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges private  subroutine dag_set_edges_vector_atts (me, ivertex, edges, attributes, label) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), dimension(:) :: attributes other attributes when\nsaving as a diagraph. character(len=*), intent(in), optional, dimension(:) :: label procedure, public :: remove_edge => dag_remove_edge private  subroutine dag_remove_edge (me, ivertex, iedge) Remove an edge from a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge the edge to remove procedure, public :: remove_vertex => dag_remove_node private  subroutine dag_remove_node (me, ivertex) Remove a node from a dag. Will also remove any edges connected to it. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex the node to remove procedure, public :: toposort => dag_toposort private  subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(out), dimension(:), allocatable :: order the toposort order integer(kind=ip), intent(out) :: istat Status flag: Read more… procedure, public :: traverse => dag_traverse private  subroutine dag_traverse (me, ivertex, userfunc) depth-first graph traversal of the dag. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex the vertex number to start on procedure( traverse_func ) :: userfunc a user-provided function that will\nbe called for each vertex/edge combination procedure, public :: generate_digraph => dag_generate_digraph private  function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer(kind=ip), intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix private  subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix procedure, public :: save_digraph => dag_save_digraph private  subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer(kind=ip), intent(in), optional :: dpi resolution (e.g. 300) procedure, public :: destroy => dag_destroy private  subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me procedure, public :: get_edge_index private pure function get_edge_index (me, ivertex, iedge) result(edge_index) Returns the index in the edge array of the vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge edge vertex number Return Value integer(kind=ip) the index of the iedge vertex in\nthe edge array (0 if not found) procedure, private :: init_internal_vars private routine to initialize some internal variables private  subroutine init_internal_vars (me) Initialize the internal private variables used for graph traversal. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me procedure, private :: dag_set_edges_vector_atts private  subroutine dag_set_edges_vector_atts (me, ivertex, edges, attributes, label) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), dimension(:) :: attributes other attributes when\nsaving as a diagraph. character(len=*), intent(in), optional, dimension(:) :: label procedure, private :: dag_set_edges_no_atts private  subroutine dag_set_edges_no_atts (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges Source Code type , public :: dag !! a directed acyclic graph (DAG). !! a collection of vertices (nodes) that are connected to other vertices. private integer ( ip ) :: n = 0 !! number of vertices (size of `vertices` array) type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. The index in !! this array if the vertex number. contains private procedure , public :: vertex => dag_get_vertex !! not very useful for now, since !! all vertex attributes are private procedure , public :: number_of_vertices => dag_get_number_of_vertices procedure , public :: get_edge_metadata => dag_get_edge_metadata procedure , public :: get_vertex_metadata => dag_get_vertex_metadata procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: add_edge => dag_add_edge generic , public :: set_edges => dag_set_edges_no_atts , & dag_set_edges_vector_atts procedure , public :: remove_edge => dag_remove_edge procedure , public :: remove_vertex => dag_remove_node procedure , public :: toposort => dag_toposort procedure , public :: traverse => dag_traverse procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: destroy => dag_destroy procedure , public :: get_edge_index procedure :: init_internal_vars !! private routine to initialize some internal variables procedure :: dag_set_edges_no_atts , dag_set_edges_vector_atts end type dag","tags":"","loc":"type/dag.html"},{"title":"traverse_func – daglib","text":"interface private  subroutine traverse_func(ivertex, stop, iedge) Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ivertex vertex number logical, intent(out) :: stop set to true to stop the process integer(kind=ip), intent(in), optional :: iedge edge index for this vertex\n(note: not the vertex number,\nthe index in the array of edge vertices)\n[not present if this is the starting node] Description user-provided function for traversing a dag.","tags":"","loc":"interface/traverse_func.html"},{"title":"edge_constructor – daglib","text":"private impure elemental function edge_constructor(ivertex, label, attributes, metadata) result(e) Constructor for edge type. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), optional :: ivertex vertex number defining the destination of this edge character(len=*), intent(in), optional :: label vertex name for grahviz character(len=*), intent(in), optional :: attributes other attributes for graphviz class(*), intent(in), optional :: metadata optional user-defined metadata Return Value type( edge ) Called by proc~~edge_constructor~~CalledByGraph proc~edge_constructor edge_constructor interface~edge edge interface~edge->proc~edge_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code impure elemental function edge_constructor ( ivertex , label , attributes , metadata ) result ( e ) integer ( ip ), intent ( in ), optional :: ivertex !! vertex number defining the destination of this edge character ( len =* ), intent ( in ), optional :: label !! vertex name for grahviz character ( len =* ), intent ( in ), optional :: attributes !! other attributes for graphviz class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata type ( edge ) :: e e % ivertex = ivertex if ( present ( label )) e % label = label if ( present ( attributes )) e % attributes = attributes if ( present ( metadata )) allocate ( e % attributes , source = attributes ) end function edge_constructor","tags":"","loc":"proc/edge_constructor.html"},{"title":"dag_get_edges – daglib","text":"private pure function dag_get_edges(me, ivertex) result(edges) get the edges for the vertex (all of the vertices\nthat this vertex depends on). Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex Return Value integer(kind=ip), dimension(:), allocatable Source Code pure function dag_get_edges ( me , ivertex ) result ( edges ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex integer ( ip ), dimension (:), allocatable :: edges if ( allocated ( me % vertices ( ivertex )% edges )) then if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges % ivertex ! auto LHS allocation end if end if end function dag_get_edges","tags":"","loc":"proc/dag_get_edges.html"},{"title":"dag_get_dependencies – daglib","text":"private pure function dag_get_dependencies(me, ivertex) result(dep) get all the vertices that depend on this vertex. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex Return Value integer(kind=ip), dimension(:), allocatable the set of all vertices\nthan depend on ivertex Source Code pure function dag_get_dependencies ( me , ivertex ) result ( dep ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex integer ( ip ), dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer ( ip ) :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges % ivertex == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies","tags":"","loc":"proc/dag_get_dependencies.html"},{"title":"dag_get_number_of_vertices – daglib","text":"private pure function dag_get_number_of_vertices(me) result(nvertices) Returns the number of vertices (nodes) in the dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me Return Value integer(kind=ip) number of vertices Source Code pure function dag_get_number_of_vertices ( me ) result ( nvertices ) class ( dag ), intent ( in ) :: me integer ( ip ) :: nvertices !! number of vertices nvertices = me % n end function dag_get_number_of_vertices","tags":"","loc":"proc/dag_get_number_of_vertices.html"},{"title":"dag_get_vertex_metadata – daglib","text":"private  function dag_get_vertex_metadata(me, ivertex) result(m) Returns the metadata for a vertex (node) in the dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number Return Value class(*), allocatable Source Code function dag_get_vertex_metadata ( me , ivertex ) result ( m ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number class ( * ), allocatable :: m if ( allocated ( me % vertices ( ivertex )% metadata )) & allocate ( m , source = me % vertices ( ivertex )% metadata ) end function dag_get_vertex_metadata","tags":"","loc":"proc/dag_get_vertex_metadata.html"},{"title":"dag_get_edge_metadata – daglib","text":"private  function dag_get_edge_metadata(me, ivertex, iedge) result(m) Returns the metadata for an edge in the dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge edge vertex Return Value class(*), allocatable Calls proc~~dag_get_edge_metadata~~CallsGraph proc~dag_get_edge_metadata dag%dag_get_edge_metadata proc~get_edge_index dag%get_edge_index proc~dag_get_edge_metadata->proc~get_edge_index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function dag_get_edge_metadata ( me , ivertex , iedge ) result ( m ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! edge vertex class ( * ), allocatable :: m associate ( i => me % get_edge_index ( ivertex , iedge ) ) if ( i > 0 ) allocate ( m , source = me % vertices ( ivertex )% edges ( i )% metadata ) end associate end function dag_get_edge_metadata","tags":"","loc":"proc/dag_get_edge_metadata.html"},{"title":"get_edge_index – daglib","text":"private pure function get_edge_index(me, ivertex, iedge) result(edge_index) Returns the index in the edge array of the vertex. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge edge vertex number Return Value integer(kind=ip) the index of the iedge vertex in\nthe edge array (0 if not found) Called by proc~~get_edge_index~~CalledByGraph proc~get_edge_index dag%get_edge_index proc~dag_get_edge_metadata dag%dag_get_edge_metadata proc~dag_get_edge_metadata->proc~get_edge_index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function get_edge_index ( me , ivertex , iedge ) result ( edge_index ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! edge vertex number integer ( ip ) :: edge_index !! the index of the `iedge` vertex in !! the edge array (0 if not found) integer ( ip ), dimension ( 1 ) :: idx if ( allocated ( me % vertices ( ivertex )% edges )) then idx = findloc ( me % vertices ( ivertex )% edges % ivertex , iedge ) edge_index = idx ( 1 ) else edge_index = 0_ip end if end function get_edge_index","tags":"","loc":"proc/get_edge_index.html"},{"title":"dag_get_vertex – daglib","text":"private  function dag_get_vertex(me, i) result(v) Get the i th vertex. The program will stop if vertex i does not exist. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: i vertex number Return Value type( vertex ) Source Code function dag_get_vertex ( me , i ) result ( v ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! vertex number type ( vertex ) :: v if ( i < 0 . or . i > me % n ) then error stop 'Error in dag_get_vertex: invalid vertex number' else v = me % vertices ( i ) end if end function dag_get_vertex","tags":"","loc":"proc/dag_get_vertex.html"},{"title":"dag_generate_digraph – daglib","text":"private  function dag_generate_digraph(me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Example To convert this to a PDF using dot : dot -Tpdf -o test.pdf test.dot ,\n    where test.dot is str written to a file. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer(kind=ip), intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable Calls proc~~dag_generate_digraph~~CallsGraph proc~dag_generate_digraph dag%dag_generate_digraph proc~integer_to_string integer_to_string proc~dag_generate_digraph->proc~integer_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dag_generate_digraph~~CalledByGraph proc~dag_generate_digraph dag%dag_generate_digraph proc~dag_save_digraph dag%dag_save_digraph proc~dag_save_digraph->proc~dag_generate_digraph Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer ( ip ), intent ( in ), optional :: dpi !! resolution (e.g. 300) integer ( ip ) :: i , j !! counter integer ( ip ) :: n_edges !! number of edges character ( len = :), allocatable :: attributes !! full attributes string for node or edge logical :: compress !! if we can write all the edges on one line character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n attributes = get_attributes_string ( me % vertices ( i )% label , & me % vertices ( i )% attributes ) str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) ! if none of the edges have attributes, ! then we can write them all on one line ! otherwise, write them line by line compress = . true . do j = 1 , n_edges if ( allocated ( me % vertices ( i )% edges ( j )% label ) . or . & allocated ( me % vertices ( i )% edges ( j )% attributes )) then compress = . false . exit end if end do if (. not . compress ) then ! Example:   1 -> 2 [penwidth=2, arrowhead=none] do j = 1 , n_edges attributes = get_attributes_string ( me % vertices ( i )% edges ( j )% label , & me % vertices ( i )% edges ( j )% attributes ) str = str // tab // integer_to_string ( i ) // ' -> ' // & integer_to_string ( me % vertices ( i )% edges ( j )% ivertex ) // ' ' // attributes // newline end do else ! Example:   1 -> 2,5,10 str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )% ivertex ) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end if end do str = str // newline // '}' contains function get_attributes_string ( label , attributes ) result ( str ) !! create the full attributes string for an edge or node. character ( len = :), allocatable , intent ( in ) :: label !! if not allocated or blank, then not used character ( len = :), allocatable , intent ( in ) :: attributes !! if not allocated or blank, then not used character ( len = :), allocatable :: str !! the attributes string, enclosed in brackets character ( len = :), allocatable :: tmp_label logical :: has_label , has_attributes has_label = allocated ( label ) if ( has_label ) has_label = label /= '' if ( has_label ) tmp_label = 'label=\"' // trim ( adjustl ( label )) // '\"' has_attributes = allocated ( attributes ) if ( has_attributes ) has_attributes = attributes /= '' if ( has_label . and . has_attributes ) then str = '[' // trim ( adjustl ( attributes )) // ',' // tmp_label // ']' elseif ( has_label . and . . not . has_attributes ) then str = '[' // tmp_label // ']' elseif (. not . has_label . and . has_attributes ) then str = '[' // trim ( adjustl ( attributes )) // ']' else ! neither str = '' end if end function get_attributes_string end function dag_generate_digraph","tags":"","loc":"proc/dag_generate_digraph.html"},{"title":"integer_to_string – daglib","text":"private pure function integer_to_string(i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value character(len=:), allocatable Called by proc~~integer_to_string~~CalledByGraph proc~integer_to_string integer_to_string proc~dag_generate_digraph dag%dag_generate_digraph proc~dag_generate_digraph->proc~integer_to_string proc~dag_set_vertices dag%dag_set_vertices proc~dag_set_vertices->proc~integer_to_string proc~dag_save_digraph dag%dag_save_digraph proc~dag_save_digraph->proc~dag_generate_digraph Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function integer_to_string ( i ) result ( s ) integer ( ip ), intent ( in ) :: i character ( len = :), allocatable :: s integer ( ip ) :: istat allocate ( character ( len = MAX_INT_STR_LEN ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string","tags":"","loc":"proc/integer_to_string.html"},{"title":"unique – daglib","text":"private  function unique(vec) result(vec_unique) Return only the unique values from vec .\nThe result is also sorted by ascending value. Arguments Type Intent Optional Attributes Name type( edge ), intent(in), dimension(:) :: vec Return Value type( edge ), dimension(:), allocatable only the unique elements of vec Calls proc~~unique~~CallsGraph proc~unique unique proc~sort_ascending sort_ascending proc~unique->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function unique ( vec ) result ( vec_unique ) type ( edge ), dimension (:), intent ( in ) :: vec type ( edge ), dimension (:), allocatable :: vec_unique !! only the unique elements of `vec` integer ( ip ) :: i !! counter integer ( ip ) :: n !! size of `vec` logical , dimension (:), allocatable :: mask !! for flagging the unique values n = size ( vec ) vec_unique = vec ! make a copy if ( n <= 1 ) return ! get the unique elements by sorting the array ! and then excluding any that are the same as the previous element. call sort_ascending ( vec_unique ) allocate ( mask ( n )); mask ( 1 ) = . true . do i = 2 , n mask ( i ) = ( vec_unique ( i )% ivertex /= vec_unique ( i - 1 )% ivertex ) end do vec_unique = pack ( vec_unique , mask ) end function unique","tags":"","loc":"proc/unique.html"},{"title":"dag_destroy – daglib","text":"private  subroutine dag_destroy(me) Destroy the dag . Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Source Code subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy","tags":"","loc":"proc/dag_destroy.html"},{"title":"set_edge_vector_vector – daglib","text":"private  subroutine set_edge_vector_vector(me, edges, label, attributes, metadata) specify the edge indices for this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), optional, dimension(:) :: label character(len=*), intent(in), optional, dimension(:) :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata Calls proc~~set_edge_vector_vector~~CallsGraph proc~set_edge_vector_vector vertex%set_edge_vector_vector proc~sort_ascending sort_ascending proc~set_edge_vector_vector->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~set_edge_vector_vector~~CalledByGraph proc~set_edge_vector_vector vertex%set_edge_vector_vector none~set_edges vertex%set_edges none~set_edges->proc~set_edge_vector_vector proc~dag_add_edge dag%dag_add_edge proc~dag_add_edge->none~set_edges proc~dag_set_edges_no_atts dag%dag_set_edges_no_atts proc~dag_set_edges_no_atts->none~set_edges proc~dag_set_edges_vector_atts dag%dag_set_edges_vector_atts proc~dag_set_edges_vector_atts->none~set_edges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_edge_vector_vector ( me , edges , label , attributes , metadata ) class ( vertex ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: edges character ( len =* ), dimension (:), intent ( in ), optional :: label character ( len =* ), dimension (:), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata ! elemental assignment: me % edges = edge ( ivertex = edges , label = label ,& attributes = attributes , metadata = metadata ) call sort_ascending ( me % edges ) end subroutine set_edge_vector_vector","tags":"","loc":"proc/set_edge_vector_vector.html"},{"title":"add_edge – daglib","text":"private  subroutine add_edge(me, e, label, attributes, metadata) add an edge index for this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e character(len=*), intent(in), optional :: label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata Calls proc~~add_edge~~CallsGraph proc~add_edge vertex%add_edge proc~sort_ascending sort_ascending proc~add_edge->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~add_edge~~CalledByGraph proc~add_edge vertex%add_edge none~set_edges vertex%set_edges none~set_edges->proc~add_edge proc~dag_add_edge dag%dag_add_edge proc~dag_add_edge->none~set_edges proc~dag_set_edges_no_atts dag%dag_set_edges_no_atts proc~dag_set_edges_no_atts->none~set_edges proc~dag_set_edges_vector_atts dag%dag_set_edges_vector_atts proc~dag_set_edges_vector_atts->none~set_edges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine add_edge ( me , e , label , attributes , metadata ) class ( vertex ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: e character ( len =* ), intent ( in ), optional :: label character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata type ( edge ) :: edge_ edge_ = edge ( ivertex = e , label = label ,& attributes = attributes , metadata = metadata ) if ( allocated ( me % edges )) then if (. not . any ( e == me % edges % ivertex )) then ! don't add if already there me % edges = [ me % edges , edge_ ] call sort_ascending ( me % edges ) end if else me % edges = [ edge_ ] end if end subroutine add_edge","tags":"","loc":"proc/add_edge.html"},{"title":"remove_edge – daglib","text":"private  subroutine remove_edge(me, e) remove an edge index from this vertex Type Bound vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e Called by proc~~remove_edge~~CalledByGraph proc~remove_edge vertex%remove_edge proc~dag_remove_edge dag%dag_remove_edge proc~dag_remove_edge->proc~remove_edge proc~dag_remove_node dag%dag_remove_node proc~dag_remove_node->proc~remove_edge Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine remove_edge ( me , e ) class ( vertex ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: e integer ( ip ), dimension ( 1 ) :: idx type ( edge ), dimension (:), allocatable :: tmp if ( allocated ( me % edges )) then idx = findloc ( me % edges % ivertex , e ) if ( idx ( 1 ) > 0 ) then ! the edge is in the list associate ( i => idx ( 1 ), n => size ( me % edges )) if ( n == 1 ) then deallocate ( me % edges ) ! it's the only one there else allocate ( tmp ( n - 1 )) if ( i > 1 ) tmp ( 1 : i - 1 ) = me % edges ( 1 : i - 1 ) if ( i < n ) tmp ( i : n - 1 ) = me % edges ( i + 1 : n ) call move_alloc ( tmp , me % edges ) end if end associate end if end if end subroutine remove_edge","tags":"","loc":"proc/remove_edge.html"},{"title":"dag_remove_node – daglib","text":"private  subroutine dag_remove_node(me, ivertex) Remove a node from a dag. Will also remove any edges connected to it. This will renumber the nodes and edges internally.\nNote that any default integer labels generated in dag_set_vertices would then be questionable. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex the node to remove Calls proc~~dag_remove_node~~CallsGraph proc~dag_remove_node dag%dag_remove_node proc~remove_edge vertex%remove_edge proc~dag_remove_node->proc~remove_edge Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_remove_node ( me , ivertex ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! the node to remove integer ( ip ) :: i !! counter type ( vertex ), dimension (:), allocatable :: tmp !! for resizing `me%vertices` if ( allocated ( me % vertices )) then associate ( n => size ( me % vertices )) do i = 1 , n ! first remove any edges: call me % vertices ( i )% remove_edge ( ivertex ) ! next, renumber the existing edges so they will be ! correct after ivertex is deleted ! Example (removing 2): 1 [2] 3 4 ==> 1 2 3 if ( allocated ( me % vertices ( i )% edges )) then where ( me % vertices ( i )% edges % ivertex > ivertex ) me % vertices ( i )% edges % ivertex = me % vertices ( i )% edges % ivertex - 1 end where end if end do ! now, remove the node: allocate ( tmp ( n - 1 )) if ( ivertex > 1 ) tmp ( 1 : ivertex - 1 ) = me % vertices ( 1 : ivertex - 1 ) if ( ivertex < n ) tmp ( ivertex : n - 1 ) = me % vertices ( ivertex + 1 : n ) call move_alloc ( tmp , me % vertices ) end associate end if me % n = size ( me % vertices ) if ( me % n == 0 ) deallocate ( me % vertices ) end subroutine dag_remove_node","tags":"","loc":"proc/dag_remove_node.html"},{"title":"dag_set_vertices – daglib","text":"private  subroutine dag_set_vertices(me, nvertices, labels, attributes, metadata) set the number of vertices (nodes) in the dag. See also dag_remove_node which can be used to remove a vertex. dag_set_vertex_info which can be used to set/change\n    the labels and other attributes. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: nvertices number of vertices character(len=*), intent(in), optional, dimension(nvertices) :: labels vertex name strings character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata Calls proc~~dag_set_vertices~~CallsGraph proc~dag_set_vertices dag%dag_set_vertices proc~dag_set_vertex_info dag%dag_set_vertex_info proc~dag_set_vertices->proc~dag_set_vertex_info proc~integer_to_string integer_to_string proc~dag_set_vertices->proc~integer_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_vertices ( me , nvertices , labels , attributes , metadata ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: nvertices !! number of vertices character ( len =* ), dimension ( nvertices ), intent ( in ), optional :: labels !! vertex name strings character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata integer ( ip ) :: i !! counter logical :: has_label !! if `labels` is specified character ( len = :), allocatable :: label_ !! temp variable for labels if ( nvertices <= 0 ) error stop 'error: nvertices must be >= 1' if ( allocated ( me % vertices )) deallocate ( me % vertices ) me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] ! vertex indices has_label = present ( labels ) do i = 1 , nvertices if ( has_label ) then label_ = trim ( adjustl ( labels ( i ))) else label_ = integer_to_string ( i ) ! just use the vertex number end if call me % set_vertex_info ( ivertex = i , label = label_ ,& attributes = attributes , metadata = metadata ) end do end subroutine dag_set_vertices","tags":"","loc":"proc/dag_set_vertices.html"},{"title":"dag_set_vertex_info – daglib","text":"private  subroutine dag_set_vertex_info(me, ivertex, label, attributes, metadata) set info about a vertex in a dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata Called by proc~~dag_set_vertex_info~~CalledByGraph proc~dag_set_vertex_info dag%dag_set_vertex_info proc~dag_set_vertices dag%dag_set_vertices proc~dag_set_vertices->proc~dag_set_vertex_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_vertex_info ( me , ivertex , label , attributes , metadata ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata if ( present ( label )) me % vertices ( ivertex )% label = label if ( present ( attributes )) me % vertices ( ivertex )% attributes = attributes if ( present ( metadata )) then if ( allocated ( me % vertices ( ivertex )% metadata )) & deallocate ( me % vertices ( ivertex )% metadata ) allocate ( me % vertices ( ivertex )% metadata , source = metadata ) end if end subroutine dag_set_vertex_info","tags":"","loc":"proc/dag_set_vertex_info.html"},{"title":"dag_add_edge – daglib","text":"private  subroutine dag_add_edge(me, ivertex, iedge, label, attributes, metadata) Add an edge to a dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge the vertex to connect to ivertex character(len=*), intent(in), optional :: label edge label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata Calls proc~~dag_add_edge~~CallsGraph proc~dag_add_edge dag%dag_add_edge none~set_edges vertex%set_edges proc~dag_add_edge->none~set_edges proc~add_edge vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector_vector vertex%set_edge_vector_vector none~set_edges->proc~set_edge_vector_vector proc~sort_ascending sort_ascending proc~add_edge->proc~sort_ascending proc~set_edge_vector_vector->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_add_edge ( me , ivertex , iedge , label , attributes , metadata ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! the vertex to connect to `ivertex` character ( len =* ), intent ( in ), optional :: label !! edge label character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata call me % vertices ( ivertex )% set_edges ( iedge ,& label = label ,& attributes = attributes ,& metadata = metadata ) end subroutine dag_add_edge","tags":"","loc":"proc/dag_add_edge.html"},{"title":"dag_set_edges_no_atts – daglib","text":"private  subroutine dag_set_edges_no_atts(me, ivertex, edges) set the edges for a vertex in a dag Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges Calls proc~~dag_set_edges_no_atts~~CallsGraph proc~dag_set_edges_no_atts dag%dag_set_edges_no_atts none~set_edges vertex%set_edges proc~dag_set_edges_no_atts->none~set_edges proc~add_edge vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector_vector vertex%set_edge_vector_vector none~set_edges->proc~set_edge_vector_vector proc~sort_ascending sort_ascending proc~add_edge->proc~sort_ascending proc~set_edge_vector_vector->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_edges_no_atts ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges_no_atts","tags":"","loc":"proc/dag_set_edges_no_atts.html"},{"title":"dag_remove_edge – daglib","text":"private  subroutine dag_remove_edge(me, ivertex, iedge) Remove an edge from a dag. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge the edge to remove Calls proc~~dag_remove_edge~~CallsGraph proc~dag_remove_edge dag%dag_remove_edge proc~remove_edge vertex%remove_edge proc~dag_remove_edge->proc~remove_edge Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_remove_edge ( me , ivertex , iedge ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! the edge to remove call me % vertices ( ivertex )% remove_edge ( iedge ) end subroutine dag_remove_edge","tags":"","loc":"proc/dag_remove_edge.html"},{"title":"dag_set_edges_vector_atts – daglib","text":"private  subroutine dag_set_edges_vector_atts(me, ivertex, edges, attributes, label) set the edges for a vertex in a dag Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), dimension(:) :: attributes other attributes when\nsaving as a diagraph. character(len=*), intent(in), optional, dimension(:) :: label Calls proc~~dag_set_edges_vector_atts~~CallsGraph proc~dag_set_edges_vector_atts dag%dag_set_edges_vector_atts none~set_edges vertex%set_edges proc~dag_set_edges_vector_atts->none~set_edges proc~add_edge vertex%add_edge none~set_edges->proc~add_edge proc~set_edge_vector_vector vertex%set_edge_vector_vector none~set_edges->proc~set_edge_vector_vector proc~sort_ascending sort_ascending proc~add_edge->proc~sort_ascending proc~set_edge_vector_vector->proc~sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_set_edges_vector_atts ( me , ivertex , edges , attributes , label ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), dimension (:), intent ( in ) :: edges character ( len =* ), dimension (:), intent ( in ) :: attributes !! other attributes when !! saving as a diagraph. character ( len =* ), dimension (:), intent ( in ), optional :: label call me % vertices ( ivertex )% set_edges ( edges , label = label , attributes = attributes ) end subroutine dag_set_edges_vector_atts","tags":"","loc":"proc/dag_set_edges_vector_atts.html"},{"title":"init_internal_vars – daglib","text":"private  subroutine init_internal_vars(me) Initialize the internal private variables used for graph traversal. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me Called by proc~~init_internal_vars~~CalledByGraph proc~init_internal_vars dag%init_internal_vars proc~dag_toposort dag%dag_toposort proc~dag_toposort->proc~init_internal_vars proc~dag_traverse dag%dag_traverse proc~dag_traverse->proc~init_internal_vars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine init_internal_vars ( me ) class ( dag ), intent ( inout ) :: me integer ( ip ) :: i !! counter do i = 1 , me % n me % vertices ( i )% marked = . false . me % vertices ( i )% checking = . false . end do end subroutine init_internal_vars","tags":"","loc":"proc/init_internal_vars.html"},{"title":"dag_toposort – daglib","text":"private  subroutine dag_toposort(me, order, istat) Main toposort routine Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(out), dimension(:), allocatable :: order the toposort order integer(kind=ip), intent(out) :: istat Status flag: 0 if no errors -1 if circular dependency\n (in this case, order will not be allocated) Calls proc~~dag_toposort~~CallsGraph proc~dag_toposort dag%dag_toposort proc~init_internal_vars dag%init_internal_vars proc~dag_toposort->proc~init_internal_vars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer ( ip ), dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer ( ip ), intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer ( ip ) :: i , iorder if ( me % n == 0 ) return ! initialize internal variables, in case ! we have called this routine before. call me % init_internal_vars () allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer ( ip ) :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j )% ivertex )) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort","tags":"","loc":"proc/dag_toposort.html"},{"title":"dag_traverse – daglib","text":"private  subroutine dag_traverse(me, ivertex, userfunc) depth-first graph traversal of the dag. This will visit each node in the graph once, and call the userfunc .\n  If some nodes are not connected to ivertex , then they will not be visited. Todo Should also add a bfs option. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex the vertex number to start on procedure( traverse_func ) :: userfunc a user-provided function that will\nbe called for each vertex/edge combination Calls proc~~dag_traverse~~CallsGraph proc~dag_traverse dag%dag_traverse proc~init_internal_vars dag%init_internal_vars proc~dag_traverse->proc~init_internal_vars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_traverse ( me , ivertex , userfunc ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! the vertex number to start on procedure ( traverse_func ) :: userfunc !! a user-provided function that will !! be called for each vertex/edge combination if ( me % n == 0 ) return ! nothing to do if ( ivertex < 0 . or . ivertex > me % n ) error stop 'invalid vertex number in dag_traverse' ! initialize internal variables, in case ! we have called this routine before. call me % init_internal_vars () call dfs ( ivertex ) contains recursive subroutine dfs ( ivertex , iedge ) !! depth-first graph traversal integer ( ip ), intent ( in ) :: ivertex !! the vertex integer ( ip ), intent ( in ), optional :: iedge !! the edge index for this vertex if ( present ( iedge )) then ! visiting an edge associate ( v => me % vertices ( me % vertices ( ivertex )% edges ( iedge )% ivertex ) ) if ( done ( v , ivertex , iedge )) return end associate else ! the starting node, no edge associate ( v => me % vertices ( ivertex ) ) if ( done ( v , ivertex , iedge )) return end associate end if end subroutine dfs recursive function done ( v , iv , ie ) result ( user_stop ) !! process this vertex in the [[dfs]] and return true if done. type ( vertex ), intent ( inout ) :: v !! vertex to process logical :: user_stop !! if the user has signaled to stop integer ( ip ), intent ( in ) :: iv !! the vertex number integer ( ip ), intent ( in ), optional :: ie !! the edge index for this vertex (if this is an edge) integer ( ip ) :: jedge !! edge counter if ( v % marked ) return ! this one has already been visited v % marked = . true . ! ! call the user's function for this node/edge combo: call userfunc ( iv , user_stop , ie ) if (. not . user_stop ) then ! continue traversing if ( allocated ( v % edges )) then do jedge = 1 , size ( v % edges ) call dfs ( v % ivertex , jedge ) if ( user_stop ) return end do end if end if end function done end subroutine dag_traverse","tags":"","loc":"proc/dag_traverse.html"},{"title":"dag_generate_dependency_matrix – daglib","text":"private  subroutine dag_generate_dependency_matrix(me, mat) Generate the dependency matrix for the DAG. This is an matrix with elements ,\nsuch that is true if vertex depends on vertex . Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix Source Code subroutine dag_generate_dependency_matrix ( me , mat ) class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer ( ip ) :: i !! vertex counter integer ( ip ) :: j !! edge counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then do j = 1 , size ( me % vertices ( i )% edges ) mat ( i , me % vertices ( i )% edges ( j )% ivertex ) = . true . end do end if end do end if end subroutine dag_generate_dependency_matrix","tags":"","loc":"proc/dag_generate_dependency_matrix.html"},{"title":"dag_save_digraph – daglib","text":"private  subroutine dag_save_digraph(me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Type Bound dag Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer(kind=ip), intent(in), optional :: dpi resolution (e.g. 300) Calls proc~~dag_save_digraph~~CallsGraph proc~dag_save_digraph dag%dag_save_digraph proc~dag_generate_digraph dag%dag_generate_digraph proc~dag_save_digraph->proc~dag_generate_digraph proc~integer_to_string integer_to_string proc~dag_generate_digraph->proc~integer_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dag_save_digraph ( me , filename , rankdir , dpi ) class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer ( ip ), intent ( in ), optional :: dpi !! resolution (e.g. 300) integer ( ip ) :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph","tags":"","loc":"proc/dag_save_digraph.html"},{"title":"sort_ascending – daglib","text":"private  subroutine sort_ascending(ivec) Sorts an edge array ivec in increasing order by vertex number.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name type( edge ), intent(inout), dimension(:) :: ivec Calls proc~~sort_ascending~~CallsGraph proc~sort_ascending sort_ascending proc~swap swap proc~sort_ascending->proc~swap Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~sort_ascending~~CalledByGraph proc~sort_ascending sort_ascending proc~add_edge vertex%add_edge proc~add_edge->proc~sort_ascending proc~set_edge_vector_vector vertex%set_edge_vector_vector proc~set_edge_vector_vector->proc~sort_ascending proc~unique unique proc~unique->proc~sort_ascending none~set_edges vertex%set_edges none~set_edges->proc~add_edge none~set_edges->proc~set_edge_vector_vector proc~dag_add_edge dag%dag_add_edge proc~dag_add_edge->none~set_edges proc~dag_set_edges_no_atts dag%dag_set_edges_no_atts proc~dag_set_edges_no_atts->none~set_edges proc~dag_set_edges_vector_atts dag%dag_set_edges_vector_atts proc~dag_set_edges_vector_atts->none~set_edges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine sort_ascending ( ivec ) type ( edge ), dimension (:), intent ( inout ) :: ivec integer ( ip ), parameter :: max_size_for_insertion_sort = 20_ip !! max size for using insertion sort. call quicksort ( 1_ip , size ( ivec , kind = ip )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ) :: ipivot !! pivot element integer ( ip ) :: i !! counter integer ( ip ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1_ip , ihigh do j = i , ilow + 1_ip , - 1_ip if ( ivec ( j )% ivertex < ivec ( j - 1_ip )% ivertex ) then call swap ( ivec ( j ), ivec ( j - 1_ip )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1_ip ) call quicksort ( ipivot + 1_ip , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ), intent ( out ) :: ipivot integer ( ip ) :: i , ii call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2_ip )) ii = ilow do i = ilow + 1_ip , ihigh if ( ivec ( i )% ivertex < ivec ( ilow )% ivertex ) then ii = ii + 1_ip call swap ( ivec ( ii ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ii )) ipivot = ii end subroutine partition end subroutine sort_ascending","tags":"","loc":"proc/sort_ascending.html"},{"title":"swap – daglib","text":"private impure elemental subroutine swap(i1, i2) Swap two edge values. Arguments Type Intent Optional Attributes Name type( edge ), intent(inout) :: i1 type( edge ), intent(inout) :: i2 Called by proc~~swap~~CalledByGraph proc~swap swap proc~sort_ascending sort_ascending proc~sort_ascending->proc~swap proc~add_edge vertex%add_edge proc~add_edge->proc~sort_ascending proc~set_edge_vector_vector vertex%set_edge_vector_vector proc~set_edge_vector_vector->proc~sort_ascending proc~unique unique proc~unique->proc~sort_ascending none~set_edges vertex%set_edges none~set_edges->proc~add_edge none~set_edges->proc~set_edge_vector_vector proc~dag_add_edge dag%dag_add_edge proc~dag_add_edge->none~set_edges proc~dag_set_edges_no_atts dag%dag_set_edges_no_atts proc~dag_set_edges_no_atts->none~set_edges proc~dag_set_edges_vector_atts dag%dag_set_edges_vector_atts proc~dag_set_edges_vector_atts->none~set_edges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code impure elemental subroutine swap ( i1 , i2 ) type ( edge ), intent ( inout ) :: i1 type ( edge ), intent ( inout ) :: i2 type ( edge ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap","tags":"","loc":"proc/swap.html"},{"title":"edge – daglib","text":"private interface edge constructor for an edge type. Calls interface~~edge~~CallsGraph interface~edge edge proc~edge_constructor edge_constructor interface~edge->proc~edge_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private impure elemental function edge_constructor (ivertex, label, attributes, metadata) result(e) Constructor for edge type. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), optional :: ivertex vertex number defining the destination of this edge character(len=*), intent(in), optional :: label vertex name for grahviz character(len=*), intent(in), optional :: attributes other attributes for graphviz class(*), intent(in), optional :: metadata optional user-defined metadata Return Value type( edge )","tags":"","loc":"interface/edge.html"},{"title":"dag_module – daglib","text":"DAG Module. Uses iso_fortran_env module~~dag_module~~UsesGraph module~dag_module dag_module iso_fortran_env iso_fortran_env module~dag_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: daglib_ip = int32 Integer working precision if not specified [4 bytes] integer, private, parameter :: ip = daglib_ip local copy of daglib_ip with a shorter name integer(kind=ip), private, parameter :: MAX_INT_STR_LEN = 64 maximum length of an integer string Interfaces private        interface edge constructor for an edge type. private impure elemental function edge_constructor (ivertex, label, attributes, metadata) result(e) Constructor for edge type. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), optional :: ivertex vertex number defining the destination of this edge character(len=*), intent(in), optional :: label vertex name for grahviz character(len=*), intent(in), optional :: attributes other attributes for graphviz class(*), intent(in), optional :: metadata optional user-defined metadata Return Value type( edge ) Abstract Interfaces abstract interface private  subroutine traverse_func(ivertex, stop, iedge) user-provided function for traversing a dag. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: ivertex vertex number logical, intent(out) :: stop set to true to stop the process integer(kind=ip), intent(in), optional :: iedge edge index for this vertex\n(note: not the vertex number,\nthe index in the array of edge vertices)\n[not present if this is the starting node] Derived Types type, private :: edge the \"to\" vertex that defines an edge. This is part of\nthe array of vertices contained without the \"from\" vertex type.\nan edge can also have optional attrubutes for graphviz. Components Type Visibility Attributes Name Initial integer(kind=ip), public :: ivertex = 0 vertex number (the index in the dag vertices array) character(len=:), public, allocatable :: label used for diagraph character(len=:), public, allocatable :: attributes used for diagraph class(*), public, allocatable :: metadata user-defined metadata Constructor constructor for an edge type. private\n\n                    impure, elemental\n                    function edge_constructor (ivertex, label, attributes, metadata) Constructor for edge type. type, private :: vertex a vertex (or node) of a directed acyclic graph (DAG) Components Type Visibility Attributes Name Initial type( edge ), private, dimension(:), allocatable :: edges these are the vertices that this vertex\ndepends on. (edges of the graph). integer(kind=ip), private :: ivertex = 0 vertex number (the index in the dag vertices array) logical, private :: checking = .false. used for toposort logical, private :: marked = .false. used for toposort character(len=:), private, allocatable :: label used for diagraph character(len=:), private, allocatable :: attributes used for diagraph class(*), private, allocatable :: metadata user-defined metadata Type-Bound Procedures generic, private :: set_edges => set_edge_vector_vector , add_edge procedure, private :: add_edge procedure, private :: set_edge_vector_vector procedure, private :: remove_edge type, public :: dag a directed acyclic graph (DAG).\na collection of vertices (nodes) that are connected to other vertices. Components Type Visibility Attributes Name Initial integer(kind=ip), private :: n = 0 number of vertices (size of vertices array) type( vertex ), private, dimension(:), allocatable :: vertices the vertices in the DAG. The index in\nthis array if the vertex number. Type-Bound Procedures procedure, public :: vertex => dag_get_vertex ../../ not very useful for now, since\nall vertex attributes are private procedure, public :: number_of_vertices => dag_get_number_of_vertices procedure, public :: get_edge_metadata => dag_get_edge_metadata procedure, public :: get_vertex_metadata => dag_get_vertex_metadata procedure, public :: get_edges => dag_get_edges procedure, public :: get_dependencies => dag_get_dependencies procedure, public :: set_vertices => dag_set_vertices procedure, public :: set_vertex_info => dag_set_vertex_info procedure, public :: add_edge => dag_add_edge generic, public :: set_edges => dag_set_edges_no_atts , dag_set_edges_vector_atts procedure, public :: remove_edge => dag_remove_edge procedure, public :: remove_vertex => dag_remove_node procedure, public :: toposort => dag_toposort procedure, public :: traverse => dag_traverse procedure, public :: generate_digraph => dag_generate_digraph procedure, public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure, public :: save_digraph => dag_save_digraph procedure, public :: destroy => dag_destroy procedure, public :: get_edge_index procedure, private :: init_internal_vars ../../ private routine to initialize some internal variables procedure, private :: dag_set_edges_vector_atts procedure, private :: dag_set_edges_no_atts Functions private impure elemental function edge_constructor (ivertex, label, attributes, metadata) result(e) Constructor for edge type. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in), optional :: ivertex vertex number defining the destination of this edge character(len=*), intent(in), optional :: label vertex name for grahviz character(len=*), intent(in), optional :: attributes other attributes for graphviz class(*), intent(in), optional :: metadata optional user-defined metadata Return Value type( edge ) private pure function dag_get_edges (me, ivertex) result(edges) get the edges for the vertex (all of the vertices\nthat this vertex depends on). Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex Return Value integer(kind=ip), dimension(:), allocatable private pure function dag_get_dependencies (me, ivertex) result(dep) get all the vertices that depend on this vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex Return Value integer(kind=ip), dimension(:), allocatable the set of all vertices\nthan depend on ivertex private pure function dag_get_number_of_vertices (me) result(nvertices) Returns the number of vertices (nodes) in the dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me Return Value integer(kind=ip) number of vertices private  function dag_get_vertex_metadata (me, ivertex) result(m) Returns the metadata for a vertex (node) in the dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number Return Value class(*), allocatable private  function dag_get_edge_metadata (me, ivertex, iedge) result(m) Returns the metadata for an edge in the dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge edge vertex Return Value class(*), allocatable private pure function get_edge_index (me, ivertex, iedge) result(edge_index) Returns the index in the edge array of the vertex. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge edge vertex number Return Value integer(kind=ip) the index of the iedge vertex in\nthe edge array (0 if not found) private  function dag_get_vertex (me, i) result(v) Get the i th vertex. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: i vertex number Return Value type( vertex ) private  function dag_generate_digraph (me, rankdir, dpi) result(str) Generate a Graphviz digraph structure for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer(kind=ip), intent(in), optional :: dpi resolution (e.g. 300) Return Value character(len=:), allocatable private pure function integer_to_string (i) result(s) Integer to allocatable string. Arguments Type Intent Optional Attributes Name integer(kind=ip), intent(in) :: i Return Value character(len=:), allocatable private  function unique (vec) result(vec_unique) Return only the unique values from vec .\nThe result is also sorted by ascending value. Arguments Type Intent Optional Attributes Name type( edge ), intent(in), dimension(:) :: vec Return Value type( edge ), dimension(:), allocatable only the unique elements of vec Subroutines private  subroutine dag_destroy (me) Destroy the dag . Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me private  subroutine set_edge_vector_vector (me, edges, label, attributes, metadata) specify the edge indices for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), optional, dimension(:) :: label character(len=*), intent(in), optional, dimension(:) :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata private  subroutine add_edge (me, e, label, attributes, metadata) add an edge index for this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e character(len=*), intent(in), optional :: label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata private  subroutine remove_edge (me, e) remove an edge index from this vertex Arguments Type Intent Optional Attributes Name class( vertex ), intent(inout) :: me integer(kind=ip), intent(in) :: e private  subroutine dag_remove_node (me, ivertex) Remove a node from a dag. Will also remove any edges connected to it. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex the node to remove private  subroutine dag_set_vertices (me, nvertices, labels, attributes, metadata) set the number of vertices (nodes) in the dag. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: nvertices number of vertices character(len=*), intent(in), optional, dimension(nvertices) :: labels vertex name strings character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata private  subroutine dag_set_vertex_info (me, ivertex, label, attributes, metadata) set info about a vertex in a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number character(len=*), intent(in), optional :: label if a label is not set,\nthen the integer vertex\nnumber is used. character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata private  subroutine dag_add_edge (me, ivertex, iedge, label, attributes, metadata) Add an edge to a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge the vertex to connect to ivertex character(len=*), intent(in), optional :: label edge label character(len=*), intent(in), optional :: attributes other attributes when\nsaving as a diagraph. class(*), intent(in), optional :: metadata optional user-defined metadata private  subroutine dag_set_edges_no_atts (me, ivertex, edges) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges private  subroutine dag_remove_edge (me, ivertex, iedge) Remove an edge from a dag. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in) :: iedge the edge to remove private  subroutine dag_set_edges_vector_atts (me, ivertex, edges, attributes, label) set the edges for a vertex in a dag Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex vertex number integer(kind=ip), intent(in), dimension(:) :: edges character(len=*), intent(in), dimension(:) :: attributes other attributes when\nsaving as a diagraph. character(len=*), intent(in), optional, dimension(:) :: label private  subroutine init_internal_vars (me) Initialize the internal private variables used for graph traversal. Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me private  subroutine dag_toposort (me, order, istat) Main toposort routine Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(out), dimension(:), allocatable :: order the toposort order integer(kind=ip), intent(out) :: istat Status flag: Read more… private  subroutine dag_traverse (me, ivertex, userfunc) depth-first graph traversal of the dag. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(inout) :: me integer(kind=ip), intent(in) :: ivertex the vertex number to start on procedure( traverse_func ) :: userfunc a user-provided function that will\nbe called for each vertex/edge combination private  subroutine dag_generate_dependency_matrix (me, mat) Generate the dependency matrix for the DAG. Read more… Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me logical, intent(out), dimension(:,:), allocatable :: mat dependency matrix private  subroutine dag_save_digraph (me, filename, rankdir, dpi) Generate a Graphviz digraph structure for the DAG and write it to a file. Arguments Type Intent Optional Attributes Name class( dag ), intent(in) :: me character(len=*), intent(in), optional :: filename file name for diagraph character(len=*), intent(in), optional :: rankdir right to left orientation (e.g. 'RL') integer(kind=ip), intent(in), optional :: dpi resolution (e.g. 300) private  subroutine sort_ascending (ivec) Sorts an edge array ivec in increasing order by vertex number.\nUses a basic recursive quicksort\n(with insertion sort for partitions with 20 elements). Arguments Type Intent Optional Attributes Name type( edge ), intent(inout), dimension(:) :: ivec private impure elemental subroutine swap (i1, i2) Swap two edge values. Arguments Type Intent Optional Attributes Name type( edge ), intent(inout) :: i1 type( edge ), intent(inout) :: i2","tags":"","loc":"module/dag_module.html"},{"title":"dag_module.F90 – daglib","text":"Source Code !******************************************************************************* !> !  DAG Module. module dag_module use iso_fortran_env implicit none private #ifdef INT8 integer , parameter , public :: daglib_ip = int8 !! Integer working precision [1 byte] #elif INT16 integer , parameter , public :: daglib_ip = int16 !! Integer working precision [2 bytes] #elif INT32 integer , parameter , public :: daglib_ip = int32 !! Integer working precision [4 bytes] #elif INT64 integer , parameter , public :: daglib_ip = int64 !! Integer working precision [8 bytes] #else integer , parameter , public :: daglib_ip = int32 !! Integer working precision if not specified [4 bytes] #endif integer , parameter :: ip = daglib_ip !! local copy of `daglib_ip` with a shorter name integer ( ip ), parameter :: MAX_INT_STR_LEN = 64 !! maximum length of an integer string type :: edge !! the \"to\" vertex that defines an edge. This is part of !! the array of vertices contained without the \"from\" [[vertex]] type. !! an edge can also have optional attrubutes for graphviz. integer ( ip ) :: ivertex = 0 !! vertex number (the index in the [[dag]] `vertices` array) character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph class ( * ), allocatable :: metadata !! user-defined metadata end type edge interface edge !! constructor for an [[edge]] type. procedure :: edge_constructor end interface edge type :: vertex !! a vertex (or node) of a directed acyclic graph (DAG) private type ( edge ), dimension (:), allocatable :: edges !! these are the vertices that this vertex !! depends on. (edges of the graph). integer ( ip ) :: ivertex = 0 !! vertex number (the index in the [[dag]] `vertices` array) logical :: checking = . false . !! used for toposort logical :: marked = . false . !! used for toposort character ( len = :), allocatable :: label !! used for diagraph character ( len = :), allocatable :: attributes !! used for diagraph class ( * ), allocatable :: metadata !! user-defined metadata contains private generic :: set_edges => set_edge_vector_vector , add_edge procedure :: set_edge_vector_vector , add_edge procedure :: remove_edge end type vertex type , public :: dag !! a directed acyclic graph (DAG). !! a collection of vertices (nodes) that are connected to other vertices. private integer ( ip ) :: n = 0 !! number of vertices (size of `vertices` array) type ( vertex ), dimension (:), allocatable :: vertices !! the vertices in the DAG. The index in !! this array if the vertex number. contains private procedure , public :: vertex => dag_get_vertex !! not very useful for now, since !! all vertex attributes are private procedure , public :: number_of_vertices => dag_get_number_of_vertices procedure , public :: get_edge_metadata => dag_get_edge_metadata procedure , public :: get_vertex_metadata => dag_get_vertex_metadata procedure , public :: get_edges => dag_get_edges procedure , public :: get_dependencies => dag_get_dependencies procedure , public :: set_vertices => dag_set_vertices procedure , public :: set_vertex_info => dag_set_vertex_info procedure , public :: add_edge => dag_add_edge generic , public :: set_edges => dag_set_edges_no_atts , & dag_set_edges_vector_atts procedure , public :: remove_edge => dag_remove_edge procedure , public :: remove_vertex => dag_remove_node procedure , public :: toposort => dag_toposort procedure , public :: traverse => dag_traverse procedure , public :: generate_digraph => dag_generate_digraph procedure , public :: generate_dependency_matrix => dag_generate_dependency_matrix procedure , public :: save_digraph => dag_save_digraph procedure , public :: destroy => dag_destroy procedure , public :: get_edge_index procedure :: init_internal_vars !! private routine to initialize some internal variables procedure :: dag_set_edges_no_atts , dag_set_edges_vector_atts end type dag abstract interface subroutine traverse_func ( ivertex , stop , iedge ) !! user-provided function for traversing a dag. import :: ip implicit none integer ( ip ), intent ( in ) :: ivertex !! vertex number logical , intent ( out ) :: stop !! set to true to stop the process integer ( ip ), intent ( in ), optional :: iedge !! edge index for this vertex !! (note: not the vertex number, !! the index in the array of edge vertices) !! [not present if this is the starting node] end subroutine traverse_func end interface contains !******************************************************************************* !******************************************************************************* !> !  Constructor for [[edge]] type. impure elemental function edge_constructor ( ivertex , label , attributes , metadata ) result ( e ) integer ( ip ), intent ( in ), optional :: ivertex !! vertex number defining the destination of this edge character ( len =* ), intent ( in ), optional :: label !! vertex name for grahviz character ( len =* ), intent ( in ), optional :: attributes !! other attributes for graphviz class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata type ( edge ) :: e e % ivertex = ivertex if ( present ( label )) e % label = label if ( present ( attributes )) e % attributes = attributes if ( present ( metadata )) allocate ( e % attributes , source = attributes ) end function edge_constructor !******************************************************************************* !******************************************************************************* !> !  Destroy the `dag`. subroutine dag_destroy ( me ) class ( dag ), intent ( inout ) :: me me % n = 0 if ( allocated ( me % vertices )) deallocate ( me % vertices ) end subroutine dag_destroy !******************************************************************************* !******************************************************************************* !> !  specify the edge indices for this vertex subroutine set_edge_vector_vector ( me , edges , label , attributes , metadata ) class ( vertex ), intent ( inout ) :: me integer ( ip ), dimension (:), intent ( in ) :: edges character ( len =* ), dimension (:), intent ( in ), optional :: label character ( len =* ), dimension (:), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata ! elemental assignment: me % edges = edge ( ivertex = edges , label = label ,& attributes = attributes , metadata = metadata ) call sort_ascending ( me % edges ) end subroutine set_edge_vector_vector !******************************************************************************* !******************************************************************************* !> !  add an edge index for this vertex subroutine add_edge ( me , e , label , attributes , metadata ) class ( vertex ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: e character ( len =* ), intent ( in ), optional :: label character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata type ( edge ) :: edge_ edge_ = edge ( ivertex = e , label = label ,& attributes = attributes , metadata = metadata ) if ( allocated ( me % edges )) then if (. not . any ( e == me % edges % ivertex )) then ! don't add if already there me % edges = [ me % edges , edge_ ] call sort_ascending ( me % edges ) end if else me % edges = [ edge_ ] end if end subroutine add_edge !******************************************************************************* !******************************************************************************* !> !  remove an edge index from this vertex subroutine remove_edge ( me , e ) class ( vertex ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: e integer ( ip ), dimension ( 1 ) :: idx type ( edge ), dimension (:), allocatable :: tmp if ( allocated ( me % edges )) then idx = findloc ( me % edges % ivertex , e ) if ( idx ( 1 ) > 0 ) then ! the edge is in the list associate ( i => idx ( 1 ), n => size ( me % edges )) if ( n == 1 ) then deallocate ( me % edges ) ! it's the only one there else allocate ( tmp ( n - 1 )) if ( i > 1 ) tmp ( 1 : i - 1 ) = me % edges ( 1 : i - 1 ) if ( i < n ) tmp ( i : n - 1 ) = me % edges ( i + 1 : n ) call move_alloc ( tmp , me % edges ) end if end associate end if end if end subroutine remove_edge !******************************************************************************* !******************************************************************************* !> !  Remove a node from a dag. Will also remove any edges connected to it. ! !  This will renumber the nodes and edges internally. !  Note that any default integer labels generated in !  [[dag_set_vertices]] would then be questionable. subroutine dag_remove_node ( me , ivertex ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! the node to remove integer ( ip ) :: i !! counter type ( vertex ), dimension (:), allocatable :: tmp !! for resizing `me%vertices` if ( allocated ( me % vertices )) then associate ( n => size ( me % vertices )) do i = 1 , n ! first remove any edges: call me % vertices ( i )% remove_edge ( ivertex ) ! next, renumber the existing edges so they will be ! correct after ivertex is deleted ! Example (removing 2): 1 [2] 3 4 ==> 1 2 3 if ( allocated ( me % vertices ( i )% edges )) then where ( me % vertices ( i )% edges % ivertex > ivertex ) me % vertices ( i )% edges % ivertex = me % vertices ( i )% edges % ivertex - 1 end where end if end do ! now, remove the node: allocate ( tmp ( n - 1 )) if ( ivertex > 1 ) tmp ( 1 : ivertex - 1 ) = me % vertices ( 1 : ivertex - 1 ) if ( ivertex < n ) tmp ( ivertex : n - 1 ) = me % vertices ( ivertex + 1 : n ) call move_alloc ( tmp , me % vertices ) end associate end if me % n = size ( me % vertices ) if ( me % n == 0 ) deallocate ( me % vertices ) end subroutine dag_remove_node !******************************************************************************* !******************************************************************************* !> !  get the edges for the vertex (all of the vertices !  that this vertex depends on). pure function dag_get_edges ( me , ivertex ) result ( edges ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex integer ( ip ), dimension (:), allocatable :: edges if ( allocated ( me % vertices ( ivertex )% edges )) then if ( ivertex > 0 . and . ivertex <= me % n ) then edges = me % vertices ( ivertex )% edges % ivertex ! auto LHS allocation end if end if end function dag_get_edges !******************************************************************************* !******************************************************************************* !> !  get all the vertices that depend on this vertex. pure function dag_get_dependencies ( me , ivertex ) result ( dep ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex integer ( ip ), dimension (:), allocatable :: dep !! the set of all vertices !! than depend on `ivertex` integer ( ip ) :: i !! vertex counter if ( ivertex > 0 . and . ivertex <= me % n ) then ! have to check all the vertices: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then if ( any ( me % vertices ( i )% edges % ivertex == ivertex )) then if ( allocated ( dep )) then dep = [ dep , i ] ! auto LHS allocation else dep = [ i ] ! auto LHS allocation end if end if end if end do end if end function dag_get_dependencies !******************************************************************************* !******************************************************************************* !> !  set the number of vertices (nodes) in the dag. ! !### See also !  * [[dag_remove_node]] which can be used to remove a vertex. !  * [[dag_set_vertex_info]] which can be used to set/change !    the labels and other attributes. subroutine dag_set_vertices ( me , nvertices , labels , attributes , metadata ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: nvertices !! number of vertices character ( len =* ), dimension ( nvertices ), intent ( in ), optional :: labels !! vertex name strings character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata integer ( ip ) :: i !! counter logical :: has_label !! if `labels` is specified character ( len = :), allocatable :: label_ !! temp variable for labels if ( nvertices <= 0 ) error stop 'error: nvertices must be >= 1' if ( allocated ( me % vertices )) deallocate ( me % vertices ) me % n = nvertices allocate ( me % vertices ( nvertices )) me % vertices % ivertex = [( i , i = 1 , nvertices )] ! vertex indices has_label = present ( labels ) do i = 1 , nvertices if ( has_label ) then label_ = trim ( adjustl ( labels ( i ))) else label_ = integer_to_string ( i ) ! just use the vertex number end if call me % set_vertex_info ( ivertex = i , label = label_ ,& attributes = attributes , metadata = metadata ) end do end subroutine dag_set_vertices !******************************************************************************* !******************************************************************************* !> !  Returns the number of vertices (nodes) in the dag. pure function dag_get_number_of_vertices ( me ) result ( nvertices ) class ( dag ), intent ( in ) :: me integer ( ip ) :: nvertices !! number of vertices nvertices = me % n end function dag_get_number_of_vertices !******************************************************************************* !******************************************************************************* !> !  Returns the metadata for a vertex (node) in the dag. function dag_get_vertex_metadata ( me , ivertex ) result ( m ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number class ( * ), allocatable :: m if ( allocated ( me % vertices ( ivertex )% metadata )) & allocate ( m , source = me % vertices ( ivertex )% metadata ) end function dag_get_vertex_metadata !******************************************************************************* !******************************************************************************* !> !  Returns the metadata for an edge in the dag. function dag_get_edge_metadata ( me , ivertex , iedge ) result ( m ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! edge vertex class ( * ), allocatable :: m associate ( i => me % get_edge_index ( ivertex , iedge ) ) if ( i > 0 ) allocate ( m , source = me % vertices ( ivertex )% edges ( i )% metadata ) end associate end function dag_get_edge_metadata !******************************************************************************* !******************************************************************************* !> !  Returns the index in the edge array of the vertex. pure function get_edge_index ( me , ivertex , iedge ) result ( edge_index ) class ( dag ), intent ( in ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! edge vertex number integer ( ip ) :: edge_index !! the index of the `iedge` vertex in !! the edge array (0 if not found) integer ( ip ), dimension ( 1 ) :: idx if ( allocated ( me % vertices ( ivertex )% edges )) then idx = findloc ( me % vertices ( ivertex )% edges % ivertex , iedge ) edge_index = idx ( 1 ) else edge_index = 0_ip end if end function get_edge_index !******************************************************************************* !******************************************************************************* !> !  set info about a vertex in a dag. subroutine dag_set_vertex_info ( me , ivertex , label , attributes , metadata ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number character ( len =* ), intent ( in ), optional :: label !! if a label is not set, !! then the integer vertex !! number is used. character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata if ( present ( label )) me % vertices ( ivertex )% label = label if ( present ( attributes )) me % vertices ( ivertex )% attributes = attributes if ( present ( metadata )) then if ( allocated ( me % vertices ( ivertex )% metadata )) & deallocate ( me % vertices ( ivertex )% metadata ) allocate ( me % vertices ( ivertex )% metadata , source = metadata ) end if end subroutine dag_set_vertex_info !******************************************************************************* !******************************************************************************* !> !  Get the `i`th vertex. ! !  The program will stop if vertex `i` does not exist. function dag_get_vertex ( me , i ) result ( v ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: i !! vertex number type ( vertex ) :: v if ( i < 0 . or . i > me % n ) then error stop 'Error in dag_get_vertex: invalid vertex number' else v = me % vertices ( i ) end if end function dag_get_vertex !******************************************************************************* !******************************************************************************* !> !  Add an edge to a dag. subroutine dag_add_edge ( me , ivertex , iedge , label , attributes , metadata ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! the vertex to connect to `ivertex` character ( len =* ), intent ( in ), optional :: label !! edge label character ( len =* ), intent ( in ), optional :: attributes !! other attributes when !! saving as a diagraph. class ( * ), intent ( in ), optional :: metadata !! optional user-defined metadata call me % vertices ( ivertex )% set_edges ( iedge ,& label = label ,& attributes = attributes ,& metadata = metadata ) end subroutine dag_add_edge !******************************************************************************* !******************************************************************************* !> !  set the edges for a vertex in a dag subroutine dag_set_edges_no_atts ( me , ivertex , edges ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), dimension (:), intent ( in ) :: edges call me % vertices ( ivertex )% set_edges ( edges ) end subroutine dag_set_edges_no_atts !******************************************************************************* !******************************************************************************* !> !  Remove an edge from a dag. subroutine dag_remove_edge ( me , ivertex , iedge ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), intent ( in ) :: iedge !! the edge to remove call me % vertices ( ivertex )% remove_edge ( iedge ) end subroutine dag_remove_edge !******************************************************************************* !******************************************************************************* !> !  set the edges for a vertex in a dag subroutine dag_set_edges_vector_atts ( me , ivertex , edges , attributes , label ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! vertex number integer ( ip ), dimension (:), intent ( in ) :: edges character ( len =* ), dimension (:), intent ( in ) :: attributes !! other attributes when !! saving as a diagraph. character ( len =* ), dimension (:), intent ( in ), optional :: label call me % vertices ( ivertex )% set_edges ( edges , label = label , attributes = attributes ) end subroutine dag_set_edges_vector_atts !******************************************************************************* !******************************************************************************* !> !  Initialize the internal private variables used for graph traversal. subroutine init_internal_vars ( me ) class ( dag ), intent ( inout ) :: me integer ( ip ) :: i !! counter do i = 1 , me % n me % vertices ( i )% marked = . false . me % vertices ( i )% checking = . false . end do end subroutine init_internal_vars !******************************************************************************* !******************************************************************************* !> !  Main toposort routine subroutine dag_toposort ( me , order , istat ) class ( dag ), intent ( inout ) :: me integer ( ip ), dimension (:), allocatable , intent ( out ) :: order !! the toposort order integer ( ip ), intent ( out ) :: istat !! Status flag: !! !! * 0 if no errors !! * -1 if circular dependency !!  (in this case, `order` will not be allocated) integer ( ip ) :: i , iorder if ( me % n == 0 ) return ! initialize internal variables, in case ! we have called this routine before. call me % init_internal_vars () allocate ( order ( me % n )) iorder = 0 ! index in order array istat = 0 ! no errors so far do i = 1 , me % n if (. not . me % vertices ( i )% marked ) call dfs ( me % vertices ( i )) if ( istat ==- 1 ) exit end do if ( istat ==- 1 ) deallocate ( order ) contains recursive subroutine dfs ( v ) !! depth-first graph traversal type ( vertex ), intent ( inout ) :: v integer ( ip ) :: j if ( istat ==- 1 ) return if ( v % checking ) then ! error: circular dependency istat = - 1 else if (. not . v % marked ) then v % checking = . true . if ( allocated ( v % edges )) then do j = 1 , size ( v % edges ) call dfs ( me % vertices ( v % edges ( j )% ivertex )) if ( istat ==- 1 ) return end do end if v % checking = . false . v % marked = . true . iorder = iorder + 1 order ( iorder ) = v % ivertex end if end if end subroutine dfs end subroutine dag_toposort !******************************************************************************* !******************************************************************************* !> !  depth-first graph traversal of the dag. ! !  This will visit each node in the graph once, and call the `userfunc`. !  If some nodes are not connected to `ivertex`, then they will not be visited. ! !@todo Should also add a bfs option. subroutine dag_traverse ( me , ivertex , userfunc ) class ( dag ), intent ( inout ) :: me integer ( ip ), intent ( in ) :: ivertex !! the vertex number to start on procedure ( traverse_func ) :: userfunc !! a user-provided function that will !! be called for each vertex/edge combination if ( me % n == 0 ) return ! nothing to do if ( ivertex < 0 . or . ivertex > me % n ) error stop 'invalid vertex number in dag_traverse' ! initialize internal variables, in case ! we have called this routine before. call me % init_internal_vars () call dfs ( ivertex ) contains recursive subroutine dfs ( ivertex , iedge ) !! depth-first graph traversal integer ( ip ), intent ( in ) :: ivertex !! the vertex integer ( ip ), intent ( in ), optional :: iedge !! the edge index for this vertex if ( present ( iedge )) then ! visiting an edge associate ( v => me % vertices ( me % vertices ( ivertex )% edges ( iedge )% ivertex ) ) if ( done ( v , ivertex , iedge )) return end associate else ! the starting node, no edge associate ( v => me % vertices ( ivertex ) ) if ( done ( v , ivertex , iedge )) return end associate end if end subroutine dfs recursive function done ( v , iv , ie ) result ( user_stop ) !! process this vertex in the [[dfs]] and return true if done. type ( vertex ), intent ( inout ) :: v !! vertex to process logical :: user_stop !! if the user has signaled to stop integer ( ip ), intent ( in ) :: iv !! the vertex number integer ( ip ), intent ( in ), optional :: ie !! the edge index for this vertex (if this is an edge) integer ( ip ) :: jedge !! edge counter if ( v % marked ) return ! this one has already been visited v % marked = . true . ! ! call the user's function for this node/edge combo: call userfunc ( iv , user_stop , ie ) if (. not . user_stop ) then ! continue traversing if ( allocated ( v % edges )) then do jedge = 1 , size ( v % edges ) call dfs ( v % ivertex , jedge ) if ( user_stop ) return end do end if end if end function done end subroutine dag_traverse !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG. ! !### Example !  * To convert this to a PDF using `dot`: `dot -Tpdf -o test.pdf test.dot`, !    where `test.dot` is `str` written to a file. function dag_generate_digraph ( me , rankdir , dpi ) result ( str ) class ( dag ), intent ( in ) :: me character ( len = :), allocatable :: str character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer ( ip ), intent ( in ), optional :: dpi !! resolution (e.g. 300) integer ( ip ) :: i , j !! counter integer ( ip ) :: n_edges !! number of edges character ( len = :), allocatable :: attributes !! full attributes string for node or edge logical :: compress !! if we can write all the edges on one line character ( len =* ), parameter :: tab = '  ' !! for indenting character ( len =* ), parameter :: newline = new_line ( ' ' ) !! line break character if ( me % n == 0 ) return str = 'digraph G {' // newline // newline if ( present ( rankdir )) & str = str // tab // 'rankdir=' // rankdir // newline // newline if ( present ( dpi )) & str = str // tab // 'graph [ dpi = ' // integer_to_string ( dpi ) // ' ]' // newline // newline ! define the vertices: do i = 1 , me % n attributes = get_attributes_string ( me % vertices ( i )% label , & me % vertices ( i )% attributes ) str = str // tab // integer_to_string ( i ) // ' ' // attributes // newline if ( i == me % n ) str = str // newline end do ! define the dependencies: do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then n_edges = size ( me % vertices ( i )% edges ) ! if none of the edges have attributes, ! then we can write them all on one line ! otherwise, write them line by line compress = . true . do j = 1 , n_edges if ( allocated ( me % vertices ( i )% edges ( j )% label ) . or . & allocated ( me % vertices ( i )% edges ( j )% attributes )) then compress = . false . exit end if end do if (. not . compress ) then ! Example:   1 -> 2 [penwidth=2, arrowhead=none] do j = 1 , n_edges attributes = get_attributes_string ( me % vertices ( i )% edges ( j )% label , & me % vertices ( i )% edges ( j )% attributes ) str = str // tab // integer_to_string ( i ) // ' -> ' // & integer_to_string ( me % vertices ( i )% edges ( j )% ivertex ) // ' ' // attributes // newline end do else ! Example:   1 -> 2,5,10 str = str // tab // integer_to_string ( i ) // merge ( ' -> ' , '    ' , n_edges /= 0 ) do j = 1 , n_edges ! comma-separated list: str = str // integer_to_string ( me % vertices ( i )% edges ( j )% ivertex ) if ( n_edges > 1 . and . j < n_edges ) str = str // ',' end do str = str // ';' // newline end if end if end do str = str // newline // '}' contains function get_attributes_string ( label , attributes ) result ( str ) !! create the full attributes string for an edge or node. character ( len = :), allocatable , intent ( in ) :: label !! if not allocated or blank, then not used character ( len = :), allocatable , intent ( in ) :: attributes !! if not allocated or blank, then not used character ( len = :), allocatable :: str !! the attributes string, enclosed in brackets character ( len = :), allocatable :: tmp_label logical :: has_label , has_attributes has_label = allocated ( label ) if ( has_label ) has_label = label /= '' if ( has_label ) tmp_label = 'label=\"' // trim ( adjustl ( label )) // '\"' has_attributes = allocated ( attributes ) if ( has_attributes ) has_attributes = attributes /= '' if ( has_label . and . has_attributes ) then str = '[' // trim ( adjustl ( attributes )) // ',' // tmp_label // ']' elseif ( has_label . and . . not . has_attributes ) then str = '[' // tmp_label // ']' elseif (. not . has_label . and . has_attributes ) then str = '[' // trim ( adjustl ( attributes )) // ']' else ! neither str = '' end if end function get_attributes_string end function dag_generate_digraph !******************************************************************************* !******************************************************************************* !> !  Generate the dependency matrix for the DAG. ! !  This is an n \\times n  matrix with elements A_{ij}, !  such that A_{ij} is true if vertex i depends on vertex j. subroutine dag_generate_dependency_matrix ( me , mat ) class ( dag ), intent ( in ) :: me logical , dimension (:,:), intent ( out ), allocatable :: mat !! dependency matrix integer ( ip ) :: i !! vertex counter integer ( ip ) :: j !! edge counter if ( me % n > 0 ) then allocate ( mat ( me % n , me % n )) mat = . false . do i = 1 , me % n if ( allocated ( me % vertices ( i )% edges )) then do j = 1 , size ( me % vertices ( i )% edges ) mat ( i , me % vertices ( i )% edges ( j )% ivertex ) = . true . end do end if end do end if end subroutine dag_generate_dependency_matrix !******************************************************************************* !******************************************************************************* !> !  Generate a Graphviz digraph structure for the DAG and write it to a file. subroutine dag_save_digraph ( me , filename , rankdir , dpi ) class ( dag ), intent ( in ) :: me character ( len =* ), intent ( in ), optional :: filename !! file name for diagraph character ( len =* ), intent ( in ), optional :: rankdir !! right to left orientation (e.g. 'RL') integer ( ip ), intent ( in ), optional :: dpi !! resolution (e.g. 300) integer ( ip ) :: iunit , istat character ( len = :), allocatable :: diagraph diagraph = me % generate_digraph ( rankdir , dpi ) open ( newunit = iunit , file = filename , status = 'REPLACE' , iostat = istat ) if ( istat == 0 ) then write ( iunit , fmt = '(A)' , iostat = istat ) diagraph else write ( * , * ) 'error opening ' // trim ( filename ) end if close ( iunit , iostat = istat ) end subroutine dag_save_digraph !******************************************************************************* !******************************************************************************* !> !  Integer to allocatable string. pure function integer_to_string ( i ) result ( s ) integer ( ip ), intent ( in ) :: i character ( len = :), allocatable :: s integer ( ip ) :: istat allocate ( character ( len = MAX_INT_STR_LEN ) :: s ) ! should be big enough write ( s , fmt = '(ss,I0)' , iostat = istat ) i if ( istat == 0 ) then s = trim ( adjustl ( s )) else s = '***' end if end function integer_to_string !******************************************************************************* !******************************************************************************* !> !  Return only the unique values from `vec`. !  The result is also sorted by ascending value. function unique ( vec ) result ( vec_unique ) type ( edge ), dimension (:), intent ( in ) :: vec type ( edge ), dimension (:), allocatable :: vec_unique !! only the unique elements of `vec` integer ( ip ) :: i !! counter integer ( ip ) :: n !! size of `vec` logical , dimension (:), allocatable :: mask !! for flagging the unique values n = size ( vec ) vec_unique = vec ! make a copy if ( n <= 1 ) return ! get the unique elements by sorting the array ! and then excluding any that are the same as the previous element. call sort_ascending ( vec_unique ) allocate ( mask ( n )); mask ( 1 ) = . true . do i = 2 , n mask ( i ) = ( vec_unique ( i )% ivertex /= vec_unique ( i - 1 )% ivertex ) end do vec_unique = pack ( vec_unique , mask ) end function unique !******************************************************************************* !******************************************************************************* !> !  Sorts an [[edge]] array `ivec` in increasing order by vertex number. !  Uses a basic recursive quicksort !  (with insertion sort for partitions with \\le 20 elements). subroutine sort_ascending ( ivec ) type ( edge ), dimension (:), intent ( inout ) :: ivec integer ( ip ), parameter :: max_size_for_insertion_sort = 20_ip !! max size for using insertion sort. call quicksort ( 1_ip , size ( ivec , kind = ip )) contains recursive subroutine quicksort ( ilow , ihigh ) !! Sort the array integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ) :: ipivot !! pivot element integer ( ip ) :: i !! counter integer ( ip ) :: j !! counter if ( ihigh - ilow <= max_size_for_insertion_sort . and . ihigh > ilow ) then ! do insertion sort: do i = ilow + 1_ip , ihigh do j = i , ilow + 1_ip , - 1_ip if ( ivec ( j )% ivertex < ivec ( j - 1_ip )% ivertex ) then call swap ( ivec ( j ), ivec ( j - 1_ip )) else exit end if end do end do elseif ( ihigh - ilow > max_size_for_insertion_sort ) then ! do the normal quicksort: call partition ( ilow , ihigh , ipivot ) call quicksort ( ilow , ipivot - 1_ip ) call quicksort ( ipivot + 1_ip , ihigh ) end if end subroutine quicksort subroutine partition ( ilow , ihigh , ipivot ) !! Partition the array, based on the !! lexical ivecing comparison. integer ( ip ), intent ( in ) :: ilow integer ( ip ), intent ( in ) :: ihigh integer ( ip ), intent ( out ) :: ipivot integer ( ip ) :: i , ii call swap ( ivec ( ilow ), ivec (( ilow + ihigh ) / 2_ip )) ii = ilow do i = ilow + 1_ip , ihigh if ( ivec ( i )% ivertex < ivec ( ilow )% ivertex ) then ii = ii + 1_ip call swap ( ivec ( ii ), ivec ( i )) end if end do call swap ( ivec ( ilow ), ivec ( ii )) ipivot = ii end subroutine partition end subroutine sort_ascending !******************************************************************************* !******************************************************************************* !> !  Swap two [[edge]] values. impure elemental subroutine swap ( i1 , i2 ) type ( edge ), intent ( inout ) :: i1 type ( edge ), intent ( inout ) :: i2 type ( edge ) :: tmp tmp = i1 i1 = i2 i2 = tmp end subroutine swap !******************************************************************************* !******************************************************************************* end module dag_module !*******************************************************************************","tags":"","loc":"sourcefile/dag_module.f90.html"}]}